n <- 1000
maxit <- 500
X <- cbind(1, matrix(runif(n * 2), ncol = 2))
beta <- c(1, 0.3, 0.2)
# poisson family with log link
Y = rpois(n,exp(X %*% beta))
family = poisson(link='log')
glmfo = function(x, y, family, method = 'constant', lr = 0.001,maxit=10000, er = 1e-12){
#initiate betas
beta = rep(0, ncol(x))
#optimize, based on lecture
for (i in 1:maxit) {
b_old = beta
mu = family$linkinv(x %*% beta)
score = t(x) %*% (y - mu)
print(c(beta,i))
if(method == "constant"){
beta = beta +  lr* score
}else{
#using momentum method
beta = beta + sum(gamma(1:(i-1))) * lr * score
}
# stop if not updating
if (sum((beta - b_old)^2) < er) {
break
}
}
return(list("coefficients" = beta))
}
glmfo(X,Y,poisson(link='log'))
n <- 1000
maxit <- 500
X <- cbind(1, matrix(runif(n * 3), ncol = 3))
beta <- c(-1, 0.2, 0.1, 0.3)
# poisson family with log link
Y = rpois(n,exp(X %*% beta))
family = poisson(link='log')
glmfo(X,Y,poisson(link='log'))
glm_hw3b <- function(X, y, family, steps, maxiter=1e3, tol=1e-12) {
stopifnot(length(steps) == maxiter)
beta <- rep(0, ncol(X))
# Gradient Descent
for (j in 1:maxiter) {
b_old <- beta # keep the old beta coefficient for comparison later
mu <- family$linkinv(X %*% beta) # E[y]: inverse link function
score <- t(X) %*% (y - mu)       # Gradient (first-order)
beta <- beta + steps[j] * score  # update beta
if (sum((beta - b_old)^2) < tol) break
}
my_list <- list("coefficients" = beta)
return(my_list)
}
glm_hw3b(X,Y,poisson(link='log'))
glm_hw3b <- function(X, y, family, maxiter=1e3, tol=1e-12) {
steps = rep(0.001,maxiter)
beta <- rep(0, ncol(X))
# Gradient Descent
for (j in 1:maxiter) {
b_old <- beta # keep the old beta coefficient for comparison later
mu <- family$linkinv(X %*% beta) # E[y]: inverse link function
score <- t(X) %*% (y - mu)       # Gradient (first-order)
beta <- beta + steps[j] * score  # update beta
if (sum((beta - b_old)^2) < tol) break
}
my_list <- list("coefficients" = beta)
return(my_list)
}
glm_hw3b <- function(X, y, family, maxiter=1e3, tol=1e-12) {
steps = rep(0.001,maxiter)
beta <- rep(0, ncol(X))
# Gradient Descent
for (j in 1:maxiter) {
b_old <- beta # keep the old beta coefficient for comparison later
mu <- family$linkinv(X %*% beta) # E[y]: inverse link function
score <- t(X) %*% (y - mu)       # Gradient (first-order)
beta <- beta + steps[j] * score  # update beta
if (sum((beta - b_old)^2) < tol) break
}
my_list <- list("coefficients" = beta)
return(my_list)
}
glm_hw3b(X,Y,poission(link = "log"))
glm_hw3b(X,Y,possion(link = "log"))
glm_hw3b(X,Y,poisson(link = "log"))
n <- 3000
maxit <- 500
X <- cbind(1, matrix(runif(n * 3), ncol = 3))
beta <- c(-1, 0.2, 0.1, 0.3)
# poisson family with log link
Y = rpois(n,exp(X %*% beta))
family = poisson(link='log')
glm_hw3b(X,Y,poisson(link = "log"))
n <- 5000
maxit <- 500
X <- cbind(1, matrix(runif(n * 3), ncol = 3))
beta <- c(-1, 0.2, 0.1, 0.3)
# poisson family with log link
Y = rpois(n,exp(X %*% beta))
family = poisson(link='log')
glm_hw3b(X,Y,poisson(link = "log"))
n <- 4000
maxit <- 500
X <- cbind(1, matrix(runif(n * 3), ncol = 3))
beta <- c(-1, 0.2, 0.1, 0.3)
# poisson family with log link
Y = rpois(n,exp(X %*% beta))
family = poisson(link='log')
glm_hw3b(X,Y,poisson(link = "log"))
n <- 5000
maxit <- 500
X <- cbind(1, matrix(rnorm(n * 3), ncol = 3))
beta <- c(-1, 0.2, 0.5, 0.6 )
# poisson family with log link
Y = rpois(n,exp(X %*% beta))
family = poisson(link='log')
glmfo = function(x, y, family, method = 'constant', lr = 0.001,maxit=10000, er = 1e-12){
#initiate betas
beta = rep(0, ncol(x))
#optimize, based on lecture
for (i in 1:maxit) {
b_old = beta
mu = family$linkinv(x %*% beta)
score = t(x) %*% (y - mu)
print(c(beta,i))
if(method == "constant"){
beta = beta +  lr* score
}else{
#using momentum method
beta = beta + sum(gamma(1:(i-1))) * lr * score
}
# stop if not updating
if (sum((beta - b_old)^2) < er) {
break
}
}
return(list("coefficients" = beta))
}
glmfo(X,Y,family)
Y
n <- 1000
maxit <- 500
X <- cbind(1, matrix(rnorm(n * 3), ncol = 3))
beta <- c(-1, 0.2, 0.5, 0.6 )
# poisson family with log link
Y = rpois(n,exp(X %*% beta))
family = poisson(link='log')
glmfo = function(x, y, family, method = 'constant', lr = 0.0001,maxit=10000, er = 1e-12){
#initiate betas
beta = rep(0, ncol(x))
#optimize, based on lecture
for (i in 1:maxit) {
b_old = beta
mu = family$linkinv(x %*% beta)
score = t(x) %*% (y - mu)
print(c(beta,i))
if(method == "constant"){
beta = beta +  lr* score
}else{
#using momentum method
beta = beta + sum(gamma(1:(i-1))) * lr * score
}
# stop if not updating
if (sum((beta - b_old)^2) < er) {
break
}
}
return(list("coefficients" = beta))
}
glmfo(X,Y,family)
glmfo = function(x, y, family, method = 'constant', lr = 0.0001,maxit=10000, er = 1e-12){
#initiate betas
beta = rep(0, ncol(x))
#optimize, based on lecture
for (i in 1:maxit) {
b_old = beta
mu = family$linkinv(x %*% beta)
score = t(x) %*% (y - mu)
print(c(beta,i))
if(method == "constant"){
beta = beta +  lr* score
}else{
#using momentum method using ita = 0.9
v = 0.9*beta + lr*score
beta = beta +  v
}
# stop if not updating
if (sum((beta - b_old)^2) < er) {
break
}
}
return(list("coefficients" = beta))
}
glmfo(X,Y,family,method = 'mom')
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(bis557)
0.2^(1:3)
glmfo = function(x, y, family, method = 'constant', lr = 0.0001,maxit=10000, er = 1e-12){
#initiate betas
beta = rep(0, ncol(x))
#optimize, based on lecture
for (i in 1:maxit) {
b_old = beta
mu = family$linkinv(x %*% beta)
score = t(x) %*% (y - mu)
print(c(beta,i))
if(method == "constant"){
beta = beta +  lr* score
}else{
#using momentum method using ita = 0.3
beta = beta +  sum(0.3^(1:i-1)) * lr * score
}
# stop if not updating
if (sum((beta - b_old)^2) < er) {
break
}
}
return(list("coefficients" = beta))
}
glmfo(X,Y,family)
glmfo(X,Y,family,method = "mom")
glmfo = function(x, y, family, method = 'constant', lr = 0.0001,maxit=10000, er = 1e-12,print = FALSE){
#initiate betas
beta = rep(0, ncol(x))
#optimize, based on lecture
for (i in 1:maxit) {
b_old = beta
mu = family$linkinv(x %*% beta)
score = t(x) %*% (y - mu)
if (print == TRUE){
print(c(beta,i))
}
else{
if(method == "constant"){
beta = beta +  lr* score
}else{
#using momentum method using ita = 0.3
beta = beta +  sum(0.3^(1:i-1)) * lr * score
}
# stop if not updating
if (sum((beta - b_old)^2) < er) {
break
}
}
}
return(list("coefficients" = beta))
}
glmfo(X,Y,family)
glmfo(X,Y,family,method = 'e')
b1 = glmfo(X,Y,f,method = "constant")
set.seed(100)
n <- 1000
X <- cbind(1, matrix(rnorm(n * 3), ncol = 3))
# poisson family with log link
beta <- c(-1, 0.2, 0.5, 0.6 )
Y = rpois(n,exp(X %*% beta))
f = poisson(link='log')
b1 = glmfo(X,Y,f,method = "constant")
b2 = glmfo(X,Y,f,method = "momentum")
tab = cbind(beta,b1,b2)
tab = cbind(beta,b1,b2)
names(tab) = c("real beta", "constatn step","adaptive momentum step")
print(tab)
tab = cbind(beta,b1$coefficients,b2$coefficients)
names(tab) = c("real beta", "constatn step","adaptive momentum step")
print(tab)
View(b1)
tab = cbind(beta,b1$coefficients,b2$coefficients)
tab
tab = as.data.frame(cbind(beta,b1$coefficients,b2$coefficients))
tab
names(tab) = c("Real Beta","Constant Step"," Adaptive Momentum Step")
print(tab)
library(devtools)
document()
setwd("/Users/bo/Desktop/2020 fall/Computational/homework-1/bis557")
document()
build_vignettes()
check()
library(bis557)
load_all()
library(bis557)
library(bis557)
library(bis557)
bis557
bis557::abort()
loaded_packages()
?glmfo
?glmfo()
install("bis557")
install("/Users/bo/Desktop/2020 fall/Computational/homework-1/bis557")
library(bis557)
document()
build_readme()
poisson(link = "log")
poisson(link = "log")$link
